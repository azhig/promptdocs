<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>9.1._10 полезных методов промпт-инжиниринга с принципами применения</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f2f5f9;
      color: #343a40;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    h1 {
    font-size:2em;
    }
    .sidebar {
      width: 300px;
      background: #ffffff;
      padding: 24px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      font-size: 14px;
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      overflow-y: auto;
    }
    .sidebar h2 {
      font-size: 16px;
      font-weight: 600;
      margin: 1em 0 0.5em;
    }
    .sidebar ul {
      list-style: none;
      margin: 0 0 1em 0;
      padding: 0 0 0 16px;
    }
    .sidebar li {
      margin-bottom: 8px;
    }
    .sidebar li.current a {
      color: #3b82f6;
      font-weight: 600;
    }
    .sidebar a {
      color: #343a40;
      text-decoration: none;
      display: block;
      transition: color 0.3s;
      font-size: 14px;
    }
    .sidebar a:hover {
      color: #3b82f6;
    }
    .content-wrapper {
      margin-left: 300px;
      padding: 40px;
    }
    .content {
      max-width: 900px;
      width: 100%;
      background: #ffffff;
      padding: 40px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.05);
      border-radius: 16px;
      margin: 0 auto;
    }
    .example-block {
      background-color: #edf2f7;
      border-left: 4px solid #3b82f6;
      border-radius: 8px;
      padding: 20px;
      margin: 24px 0;
      position: relative;
      overflow-x: auto;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      color: #495057;
    }
    .example-block pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 0;
      font-family: 'Inter', sans-serif;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.3s;
    }
    .copy-btn:hover {
      background: #2563eb;
    }
    p {
      margin-bottom: 16px;
      line-height: 1.6;
    }
    .channel-footer {
      margin-top: 24px;
      text-align: center;
      font-size: 14px;
    }
    .channel-footer a {
      color: #3b82f6;
      text-decoration: none;
    }

    /* Модалка для закрытых статей */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .modal-overlay.show {
      display: flex;
    }
    .modal-box {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      max-width: 600px;
      width: 90%;
      max-height: 80%;
      overflow-y: auto;
      position: relative;
      padding: 24px;
    }
    .modal-box h2 {
      margin-top: 0;
    }
    .close-modal {
      position: absolute;
      top: 10px;
      right: 16px;
      cursor: pointer;
      font-size: 24px;
      border: none;
      background: none;
      color: #999;
    }
    .close-modal:hover {
      color: #333;
    }
  </style>
</head>
<body>

<div class="sidebar">
  <nav>
<h2>1. Цепочки рассуждений и парадигмы Chain-of-X</h2>
<ul>
<li><a href="1.1._Beyond Chain-of-Thought Обзор парадигм Chain-of-X для LLM.html">1.1._Beyond Chain-of-Thought Обзор парадигм Chain-of-X для LLM</a></li>
<li><a href="1.2._Chain-of-Reasoning CoR Многопарадигмальный подход к математическим рассуждениям в LLM.html">1.2._Chain-of-Reasoning CoR Многопарадигмальный подход к математическим рассуждениям в LLM</a></li>
<li><a href="1.3._Tree of Thoughts ToT Метод продуманного решения задач с помощью больших языковых моделей.html">1.3._Tree of Thoughts ToT Метод продуманного решения задач с помощью больших языковых моделей</a></li>
<li><a href="1.4._Understanding Before Reasoning Улучшение цепочки рассуждений с помощью итеративного суммирования.html">1.4._Understanding Before Reasoning Улучшение цепочки рассуждений с помощью итеративного суммирования</a></li>
<li><a href="1.5._Концептуально-ориентированная цепочка рассуждений (CGCoT) для сравнения текстов.html">1.5._Концептуально-ориентированная цепочка рассуждений (CGCoT) для сравнения текстов</a></li>
<li><a href="1.6._Каузальная цепочка рассуждений CauCoT Причинный подход к CoT.html">1.6._Каузальная цепочка рассуждений CauCoT Причинный подход к CoT</a></li>
<li><a href="1.7._Chain of Draft (CoD)  Минималистичные рассуждения для эффективности.html">1.7._Chain of Draft (CoD)  Минималистичные рассуждения для эффективности</a></li>
<li><a href="1.8._Chain-of-Verification.html">1.8._Chain-of-Verification</a></li>
<li><a href="1.9._Методики, дополняющие Chain of Thought CoT.html">1.9._Методики, дополняющие Chain of Thought CoT</a></li>
<li><a href="1.10._Strategic Chain-of-Thought (SCoT).html">1.10._Strategic Chain-of-Thought (SCoT)</a></li>
<li><a href="1.11._Самоорганизованная цепочка размышлений.html">1.11._Самоорганизованная цепочка размышлений</a></li>
<li><a href="1.12._Цепочка руководства Chain of Guidance перефразирование вопросов и сравнение ответовdoc.html">1.12._Цепочка руководства Chain of Guidance перефразирование вопросов и сравнение ответовdoc</a></li>
<li><a href="1.13._Основные принципы метода Chain of Thought (CoT).html">1.13._Основные принципы метода Chain of Thought (CoT)</a></li>
<li><a href="1.14._Причинное рассуждение цепочкой мыслей (CauCoT).html">1.14._Причинное рассуждение цепочкой мыслей (CauCoT)</a></li>
<li><a href="1.15._Program of Thought (PoT) Структурированное программное рассуждение для сложных задач.html">1.15._Program of Thought (PoT) Структурированное программное рассуждение для сложных задач</a></li>
</ul>
<h2>2. Методы и стратегии оптимизации промптов</h2>
<ul>
<li><a href="2.1._Heuristic Prompt Strategy Search HPSS—Оптимизация стратегий промптов.html">2.1._Heuristic Prompt Strategy Search HPSS—Оптимизация стратегий промптов</a></li>
<li><a href="2.2._Ансамблевый формат промптов.html">2.2._Ансамблевый формат промптов</a></li>
<li><a href="2.3._Гибридные стратегии - комбинирование различных подходов промптинга.html">2.3._Гибридные стратегии - комбинирование различных подходов промптинга</a></li>
<li><a href="2.4._Структурированная подача информации - имитация RAG-подхода.html">2.4._Структурированная подача информации - имитация RAG-подхода</a></li>
<li><a href="2.5._Каскадный метод размещения информации в промптах.html">2.5._Каскадный метод размещения информации в промптах</a></li>
<li><a href="2.6._Стратегия Chunking разделение больших текстов.html">2.6._Стратегия Chunking разделение больших текстов</a></li>
<li><a href="2.7._Использование элементов неестественного языка в промптах.html">2.7._Использование элементов неестественного языка в промптах</a></li>
<li><a href="2.8._Комбинирование декларативных и императивных инструкций.html">2.8._Комбинирование декларативных и императивных инструкций</a></li>
<li><a href="2.9._Включение примеров в контекст.html">2.9._Включение примеров в контекст</a></li>
<li><a href="2.10._Имитация графов знаний.html">2.10._Имитация графов знаний</a></li>
<li><a href="2.11._Использование конкретных ролей вместо общих в промпт-инжиниринге.html">2.11._Использование конкретных ролей вместо общих в промпт-инжиниринге</a></li>
<li><a href="2.12._Двухэтапное создание промптов.html">2.12._Двухэтапное создание промптов</a></li>
<li><a href="2.13._Метод Ask-when-Needed AwN полное практическое руководство.html">2.13._Метод Ask-when-Needed AwN полное практическое руководство</a></li>
<li><a href="2.14._Мета-промптинг структура и синтаксис промптов.html">2.14._Мета-промптинг структура и синтаксис промптов</a></li>
</ul>
<h2>3. Техники самоконтроля и итеративного улучшения</h2>
<ul>
<li><a href="3.1._Метод Self Refine Самопроверка и итеративное улучшение ответов.html">3.1._Метод Self Refine Самопроверка и итеративное улучшение ответов</a></li>
<li><a href="3.2._Итеративная пошаговая рефлексия.html">3.2._Итеративная пошаговая рефлексия</a></li>
<li><a href="3.3._Метод промежуточного резюмирования InftyThink.html">3.3._Метод промежуточного резюмирования InftyThink</a></li>
<li><a href="3.4._Многократная проверка.html">3.4._Многократная проверка</a></li>
<li><a href="3.5._Итеративность.html">3.5._Итеративность</a></li>
<li><a href="3.6._Эвристический поиск стратегий.html">3.6._Эвристический поиск стратегий</a></li>
</ul>
<h2>4. Когнитивные и психологические аспекты промпт-инжиниринга</h2>
<ul>
<li><a href="4.1._Иллюзия контроля Провал иерархий инструкций в крупных языковых моделях.html">4.1._Иллюзия контроля Провал иерархий инструкций в крупных языковых моделях</a></li>
<li><a href="4.2._Снижение когнитивной нагрузки в промпт-инжиниринге.html">4.2._Снижение когнитивной нагрузки в промпт-инжиниринге</a></li>
<li><a href="4.3._Когнитивная обоснованность в промпт-инжиниринге.html">4.3._Когнитивная обоснованность в промпт-инжиниринге</a></li>
<li><a href="4.4._Эффект Позиционного Предпочтения в Промпт-Инжинирингеdoc.html">4.4._Эффект Позиционного Предпочтения в Промпт-Инжинирингеdoc</a></li>
<li><a href="4.5._Предвзятость формата.html">4.5._Предвзятость формата</a></li>
<li><a href="4.6._Контрастное рассуждение в промпт-инжиниринге.html">4.6._Контрастное рассуждение в промпт-инжиниринге</a></li>
<li><a href="4.7._Рассуждения делают большие языковые модели (LLMs) более уверенными в себе, даже когда они ошибаются.html">4.7._Рассуждения делают большие языковые модели (LLMs) более уверенными в себе, даже когда они ошибаются</a></li>
</ul>
<h2>5. Форматирование, структурирование и организация информации в промптах</h2>
<ul>
<li><a href="5.1._Основные принципы влияния форматирования запросов.html">5.1._Основные принципы влияния форматирования запросов</a></li>
<li><a href="5.2._Порядок компонентов в промпте.html">5.2._Порядок компонентов в промпте</a></li>
<li><a href="5.3._Порядок компонентов в промпте как последовательность элементов влияет на результат.html">5.3._Порядок компонентов в промпте как последовательность элементов влияет на результат</a></li>
<li><a href="5.4._Стандартная структура эффективных промптов Роль Контекст Инструкция.html">5.4._Стандартная структура эффективных промптов Роль Контекст Инструкция</a></li>
<li><a href="5.5._Исследование о Bulleted Structure (Маркированной структуре промптов).html">5.5._Исследование о Bulleted Structure (Маркированной структуре промптов)</a></li>
<li><a href="5.6._Топ-5 техник саммаризации из исследований.html">5.6._Топ-5 техник саммаризации из исследований</a></li>
<li><a href="5.7._10 техник структурирования промптов из исследований.html">5.7._10 техник структурирования промптов из исследований</a></li>
<li><a href="5.8._Теоретические основы многоэтапности в промпт-инжиниринге.html">5.8._Теоретические основы многоэтапности в промпт-инжиниринге</a></li>
</ul>
<h2>6. Контекстуальность и специфика в промптах</h2>
<ul>
<li><a href="6.1._Контекстуальность в промпт-инжиниринге.html">6.1._Контекстуальность в промпт-инжиниринге</a></li>
<li><a href="6.2._Активация специфических знаний в промпт-инжиниринге.html">6.2._Активация специфических знаний в промпт-инжиниринге</a></li>
<li><a href="6.3._Сохранение контекстуальной связности.html">6.3._Сохранение контекстуальной связности</a></li>
<li><a href="6.4._Перевзвешивание контента.html">6.4._Перевзвешивание контента</a></li>
<li><a href="6.5._Принцип специфичности в промпт-инжиниринге.html">6.5._Принцип специфичности в промпт-инжиниринге</a></li>
<li><a href="6.6._Что такое пространственные паттерны в промпта.html">6.6._Что такое пространственные паттерны в промпта</a></li>
</ul>
<h2>7. Оценка и метрики качества промптов</h2>
<ul>
<li><a href="7.1._Добавление критериев оценки в промптах.html">7.1._Добавление критериев оценки в промптах</a></li>
<li><a href="7.2._Добавление критериев оценки.html">7.2._Добавление критериев оценки</a></li>
<li><a href="7.3._Шкала оценки.html">7.3._Шкала оценки</a></li>
<li><a href="7.4._Многомерная оценка ответов.html">7.4._Многомерная оценка ответов</a></li>
<li><a href="7.5._8 ключевых факторов HPSS, влияющих на качество ответов языковых моделей.html">7.5._8 ключевых факторов HPSS, влияющих на качество ответов языковых моделей</a></li>
</ul>
<h2>8. Контрфактические и альтернативные методы промптинга</h2>
<ul>
<li><a href="8.1._Техники, похожие на Контрфактический согласованный промптинг (CCP).html">8.1._Техники, похожие на Контрфактический согласованный промптинг (CCP)</a></li>
<li><a href="8.2._Суть контрфактического согласованного промптинга (CCP).html">8.2._Суть контрфактического согласованного промптинга (CCP)</a></li>
<li><a href="8.3._Большие языковые модели как контрастивные рассуждатели.html">8.3._Большие языковые модели как контрастивные рассуждатели</a></li>
<li><a href="8.4._Meta Prompting для ИИ-систем принципы и практическое применение.html">8.4._Meta Prompting для ИИ-систем принципы и практическое применение</a></li>
<li><a href="8.5._Эксперименты со стилем запросов.html">8.5._Эксперименты со стилем запросов</a></li>
<li><a href="8.6._Яркие примеры влияния стилей запросов на ответы языковых моделей.html">8.6._Яркие примеры влияния стилей запросов на ответы языковых моделей</a></li>
<li><a href="8.7._Детальное описание ограничений в промпт-инжиниринге.html">8.7._Детальное описание ограничений в промпт-инжиниринге</a></li>
<li><a href="8.8._MultiAgentBench.html">8.8._MultiAgentBench</a></li>
<li><a href="8.9._Ключевые принципы декомпозиции информации.html">8.9._Ключевые принципы декомпозиции информации</a></li>
</ul>
<h2>9. Нишевые подборки промптинга</h2>
<ul>
<li class="current"><a href="9.1._10 полезных методов промпт-инжиниринга с принципами применения.html">9.1._10 полезных методов промпт-инжиниринга с принципами применения</a></li>
<li><a href="9.2._10 WOW-техник промпт-инжиниринга из исследований.html">9.2._10 WOW-техник промпт-инжиниринга из исследований</a></li>
<li><a href="9.3._Топ-10 техник промпт-инжиниринга для SEO из исследований.html">9.3._Топ-10 техник промпт-инжиниринга для SEO из исследований</a></li>
</ul>
</nav>

</div>

<div class="content-wrapper">
  <article class="content">
    <h1>9.1. 10 полезных методов промпт-инжиниринга с принципами применения</h1>
<p><div class="chat-message-markdown"> <h2>1. Program of Thought (PoT)</h2> <p><strong>Принцип:</strong> Структурирование решения через программный код вместо обычного текстового рассуждения, что позволяет формализовать логику и избежать арифметических ошибок.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
Задача: 
В магазине скидка на все товары составляет 15%. Анна купила блузку за 2550 рублей со скидкой. Сколько стоила блузка до скидки?

# Сначала проанализируем задачу
# Если цена со скидкой 2550 рублей, а скидка 15%, нам нужно найти исходную цену

def calculate_original_price(discounted_price, discount_percentage):
    # Исходная цена = Цена со скидкой / (1 - процент скидки/100)
    original_price = discounted_price / (1 - discount_percentage/100)
    return original_price

discounted_price = 2550  # рублей
discount_percentage = 15  # процентов

original_price = calculate_original_price(discounted_price, discount_percentage)
print(f"Блузка стоила {original_price} рублей до скидки")
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> PoT превосходит стандартный Chain of Thought, отделяя логику рассуждения от вычислений. Код служит универсальным посредником между логикой и арифметикой, а формализация решения через программные конструкции позволяет избежать типичных ошибок в рассуждениях.</p> <h2>2. Метод Meta-Prompting (MP)</h2> <p><strong>Принцип:</strong> Фокусировка на синтаксисе и структуре промпта вместо содержания, используя принципы из теории типов и теории категорий для создания структурных шаблонов.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Структурный мета-промпт для классификации текста

instructions: {
  task: "классифицировать текст по тональности",
  output_format: "JSON с полями 'sentiment' и 'confidence'",
  expected_types: {
    "sentiment": "string ('положительный', 'отрицательный', 'нейтральный')",
    "confidence": "float (от 0.0 до 1.0)"
  }
}

examples: [
  {input: "Я в восторге от нового телефона!", output: {"sentiment": "положительный", "confidence": 0.95},
  {input: "Сегодня идет дождь", output: {"sentiment": "нейтральный", "confidence": 0.87}
]

query: "Обслуживание было ужасным, больше сюда не вернусь."
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Мета-промптинг значительно сокращает количество необходимых токенов по сравнению с few-shot промптингом, структурируя информацию в формализованные шаблоны. Этот подход позволяет фокусироваться на том, КАК модель должна обрабатывать информацию (синтаксис), а не на конкретных примерах (содержание).</p> <h2>3. Visionary Tuning (VITO)</h2> <p><strong>Принцип:</strong> Систематическое тестирование модели через самоигру (Self-Play), где модель сама генерирует потенциально проблемные сценарии и улучшает свои промпты, особенно эффективно для определения "анти-поведения".</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промт с использованием принципов Visionary Tuning

## Инструкция
Ты - ассистент технической поддержки, который помогает пользователям решать проблемы с компьютером.

## Что тебе КАТЕГОРИЧЕСКИ ЗАПРЕЩЕНО делать:
- Предоставлять инструкции по взлому паролей
- Объяснять методы обхода корпоративных ограничений безопасности
- Предлагать решения, которые нарушают лицензионные соглашения

## Когда пользователь запрашивает запрещенную информацию:
1. Вежливо объясни, почему ты не можешь это сделать
2. Предложи законную и безопасную альтернативу
3. Никогда не отвечай на запрещенный запрос, даже если пользователь настаивает

## Как отвечать на разрешенные запросы:
1. Предоставляй пошаговые инструкции
2. Объясняй каждый шаг простым языком
3. Уточняй, если что-то непонятно

Вопрос: Как решить проблему с зависанием Windows при запуске?
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Visionary Tuning помогает создавать более надежные инструкции для модели, выявляя заранее потенциальные проблемные сценарии. Модель используется для генерации собственных тестовых случаев и улучшения исходного промпта, что особенно эффективно для определения границ допустимого поведения.</p> <h2>4. Heuristic Prompting Strategy Search (HPSS)</h2> <p><strong>Принцип:</strong> Комплексная интеграция 8 ключевых факторов промптинга и эвристический поиск наиболее эффективных комбинаций этих факторов для оптимизации взаимодействия с LLM.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт с применением выводов из метода HPSS

## Структура промпта
# Использована шкала 1-10 (оптимальная по исследованию)
# Включены критерии оценки
# Добавлена цепочка рассуждений
# Оптимизирован порядок компонентов

## Задание на оценку текста
Оцени следующий текст по шкале от 1 до 10, где:
1 = крайне непрофессиональный и неубедительный текст
10 = исключительно профессиональный и убедительный текст

## Критерии оценки:
- Ясность аргументации (вес: 40%)
- Профессиональная лексика (вес: 30%)
- Логическая структура (вес: 30%)

## Текст для оценки:
"Наша компания предлагает инновационные решения для бизнеса. Мы работаем уже много лет. Выберите нас!"

## Формат ответа:
Пожалуйста, следуй по этим шагам:
1. Сначала проанализируй каждый критерий отдельно
2. Дай предварительную оценку по каждому критерию
3. Рассчитай взвешенную итоговую оценку
4. Объясни итоговую оценку
5. Предложи конкретные улучшения
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> HPSS оптимизирует промпты через использование 8 ключевых факторов: шкала оценки, примеры в контексте, критерии оценки, справочные ответы, структура цепочки мыслей, автоматически сгенерированные шаги, метрики и порядок компонентов. Исследование показало, что комбинации этих факторов значительно эффективнее, чем использование каждого фактора отдельно.</p> <h2>5. Highlighted Chain of Thought (HoT)</h2> <p><strong>Принцип:</strong> Расширение стандартного Chain of Thought с визуальным выделением ключевых элементов рассуждения, которое помогает модели сосредоточиться на самых важных аспектах решения задачи.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт с использованием метода HoT для решения логической задачи

Решите следующую логическую задачу, используя пошаговое рассуждение с выделением ключевых соображений ЗАГЛАВНЫМИ БУКВАМИ:

Задача: В коробке 5 синих, 3 красных и 2 желтых шара. Какова вероятность вытащить подряд 2 шара одного цвета, если первый шар не возвращается в коробку?

Решение:
1. Сначала определю, СКОЛЬКО ВСЕГО ШАРОВ - 5 + 3 + 2 = 10 ШАРОВ ВСЕГО
2. Теперь рассчитаю вероятность вытащить 2 шара одного цвета
   a) ВЕРОЯТНОСТЬ ВЫТАЩИТЬ 2 СИНИХ ШАРА:
      - Первый шар синий: 5/10
      - Второй шар синий (при условии, что первый синий): 4/9
      - Вероятность вытащить 2 синих шара: (5/10) × (4/9) = 20/90 = 2/9
   b) ВЕРОЯТНОСТЬ ВЫТАЩИТЬ 2 КРАСНЫХ ШАРА:
      - Первый шар красный: 3/10
      - Второй шар красный (при условии, что первый красный): 2/9
      - Вероятность вытащить 2 красных шара: (3/10) × (2/9) = 6/90 = 1/15
   c) ВЕРОЯТНОСТЬ ВЫТАЩИТЬ 2 ЖЕЛТЫХ ШАРА:
      - Первый шар желтый: 2/10 = 1/5
      - Второй шар желтый (при условии, что первый желтый): 1/9
      - Вероятность вытащить 2 желтых шара: (1/5) × (1/9) = 1/45
3. ОБЩАЯ ВЕРОЯТНОСТЬ = 2/9 + 1/15 + 1/45 = (10/45) + (3/45) + (1/45) = 14/45
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Выделение ключевых элементов рассуждения помогает модели создавать более точные и структурированные ответы, разбивая сложное рассуждение на четко обозначенные компоненты. Это улучшает точность и повышает надежность рассуждения, особенно для сложных логических и математических задач, где важно выделить критические шаги.</p> <h2>6. Дивергентно-конвергентное мышление (McGyver)</h2> <p><strong>Принцип:</strong> Стратегия промптинга для творческого решения проблем, которая сначала расширяет возможные варианты использования предметов (дивергентная фаза), а затем сужает их до конкретного решения (конвергентная фаза).</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт с применением дивергентно-конвергентного мышления

## Задача
Предложи способ измерить высоту здания, используя только барометр, но не как измерительный инструмент давления.

## Инструкции
1. ДИВЕРГЕНТНАЯ ФАЗА: Перечисли все возможные свойства и характеристики барометра (физические, механические и т.д.)
   * Вес и масса барометра
   * Форма и размеры
   * Материал корпуса
   * Тень, отбрасываемая барометром
   * Способность падать
   * Способность отражать свет
   * Время падения

2. КОНВЕРГЕНТНАЯ ФАЗА: Для каждого свойства предложи способ использования для решения задачи
   * Выбери 3 наиболее практичных решения
   * Опиши подробно реализацию каждого решения
   * Укажи преимущества и недостатки

3. ЗАКЛЮЧЕНИЕ: Выбери наиболее эффективное решение и объясни, почему оно лучшее
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Этот метод структурирует творческий процесс мышления, сначала побуждая к генерации максимального количества возможных решений на основе свойств объектов (дивергентная фаза), а затем к критической оценке и выбору оптимального решения (конвергентная фаза). Исследование показывает, что такой подход значительно улучшает способность LLM решать творческие задачи с ограничениями.</p> <h2>7. Персонализированные классификаторы (PC)</h2> <p><strong>Принцип:</strong> Адаптация промптов для создания классификаторов, оптимизированных под конкретные типы контента и задачи, с учетом различий в эффективности разных стратегий для разных типов данных.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт для создания персонализированного классификатора текстов

## Контекст и настройка
Я создаю систему для классификации отзывов клиентов ресторана. Мне нужен классификатор, который определит:
1. Категорию отзыва (еда/сервис/атмосфера/цена)
2. Эмоциональную окраску (положительная/отрицательная/нейтральная)

## Инструкции
Для этой конкретной задачи:
- Используй метод построения персонализированного классификатора
- Адаптируй классификатор специально для ресторанных отзывов
- Учитывай специфическую лексику ресторанной сферы
- Добавь гибридный подход (правила + примеры)

## Примеры для калибровки
1. "Паста была восхитительной, но обслуживание заставило ждать 20 минут" → {"категория": "еда+сервис", "окраска": "смешанная"}
2. "Цены слишком высокие для такого качества" → {"категория": "цена+еда", "окраска": "отрицательная"}
3. "Приятная атмосфера, тихая музыка" → {"категория": "атмосфера", "окраска": "положительная"}

## Тестовый случай
Классифицируй следующий отзыв: "Интерьер ресторана потрясающий, но официант был невнимательным и забыл про наш заказ"
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Персонализированные классификаторы работают за счет адаптации промптов под конкретный тип данных и задачу, объединяя подходы на основе правил и примеров. Исследования показывают, что разные стратегии промптинга эффективны для разных типов данных, и гибридный подход часто дает лучшие результаты, чем использование одного метода.</p> <h2>8. Iterated Specific Prompting with Self-Prompting (ISP²)</h2> <p><strong>Принцип:</strong> Итеративное уточнение и специализация промптов через механизм самопромптинга, где модель последовательно улучшает качество своих ответов на основе предыдущих рассуждений.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Итеративный промпт с самопромптингом для улучшения ответа

## Фаза 1: Начальный специфический промпт
Напиши краткую статью о влиянии искусственного интеллекта на рынок труда. Сфокусируйся на последних 5 лет и приведи конкретные примеры профессий, которые были автоматизированы.

## Фаза 2: Самопромптинг
Теперь проанализируй свой ответ и задай себе 3-5 уточняющих вопросов, на которые не ответил в первоначальной статье. Запиши эти вопросы.

## Фаза 3: Улучшение через специфические промпты
Ответь на каждый из сформулированных вопросов, предоставляя конкретные данные, статистику и примеры. Расширь первоначальную статью, включив эти ответы.

## Фаза 4: Финальная интеграция
Перепиши статью, гармонично интегрируя все собранные данные в единый, связный и информативный текст. Добавь сбалансированную перспективу - как позитивные, так и негативные аспекты влияния ИИ на рынок труда.
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> ISP² работает через последовательное улучшение качества ответов в несколько этапов. Модель сначала генерирует начальный ответ, затем задает себе уточняющие вопросы для расширения охвата темы, после чего отвечает на эти вопросы и интегрирует дополнительную информацию в final высококачественный ответ. Исследования показывают, что такой метод значительно повышает полноту, точность и глубину ответов.</p> <h2>9. Random Idea Injection (RII)</h2> <p><strong>Принцип:</strong> Введение случайных идей или концепций в промпт для стимуляции творческого мышления и преодоления ограничений стандартных подходов к решению задач.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт с использованием Random Idea Injection для маркетинга

## Задача
Разработать креативную маркетинговую концепцию для нового энергетического напитка.

## Инструкции с внедрением случайных идей
1. Основная цель: создать запоминающуюся кампанию для энергетического напитка
2. Целевая аудитория: активные люди 18-35 лет

### Случайные идеи для интеграции (выбери минимум 3):
- Квантовая механика
- Древние морские путешествия
- Стрит-арт культура
- Лунные циклы
- Ретро-видеоигры 80-х годов
- Экзотические джунгли
- Подводные вулканы
- Нейронные связи мозга
- Циркадные ритмы

3. Для каждой выбранной идеи предложи способ интеграции в маркетинговую концепцию
4. Затем объедини эти элементы в единую креативную концепцию
5. Создай название кампании, основной слоган и 3 ключевых визуальных элемента
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Метод Random Idea Injection работает за счет вывода мышления из стандартных паттернов через намеренное введение неожиданных концепций. Это активирует новые ассоциативные связи в процессе генерации текста LLM, что приводит к более оригинальным и инновационным решениям. Исследования показывают, что данный подход особенно эффективен для творческих задач, где важно преодолеть когнитивные шаблоны.</p> <h2>10. Cognitive Bias Detection (CBD)</h2> <p><strong>Принцип:</strong> Структурированный метод промпт-инжиниринга для обнаружения когнитивных искажений в тексте, который фокусируется на выявлении определенных типов предубеждений и логических ошибок.</p> <p><strong>Практическое применение:</strong></p></p>
<div class="example-block"><button class="copy-btn" onclick="copyCode(this)">Копировать</button><pre><code>[======]
# Промпт для обнаружения когнитивных искажений в тексте

## Задача
Проанализируй следующий текст и выяви возможные когнитивные искажения.

## Инструкции
1. Последовательно проверь текст на наличие следующих когнитивных искажений:
   - Подтверждение предвзятости (тенденция искать информацию, подтверждающую существующие убеждения)
   - Эффект знания задним числом (убеждение, что событие было предсказуемо после того, как оно произошло)
   - Фундаментальная ошибка атрибуции (переоценка личностных факторов и недооценка ситуационных)
   - Эффект якоря (чрезмерное влияние первой полученной информации)
   - Групповое мышление (тенденция к консенсусу за счет критического мышления)

2. Для каждого обнаруженного искажения:
   - Укажи конкретный фрагмент текста, содержащий искажение
   - Объясни, какое именно искажение присутствует и почему
   - Предложи, как можно переформулировать утверждение, чтобы снизить влияние искажения

3. Представь результаты в структурированном виде с оценкой общего уровня предвзятости текста

## Текст для анализа:
"Разумеется, каждый знал, что финансовый кризис неизбежен. Все признаки были налицо, и только безответственные политики могли его не заметить. Очевидно, что это результат их некомпетентности, а не сложных системных проблем. Наша компания всегда предупреждала о возможных рисках, в отличие от других, которые просто следовали за толпой."
[======]
</code></pre></div>
<p><p><strong>Механизм работы:</strong> Метод CBD работает через структурированный анализ текста на предмет конкретных типов когнитивных искажений. Исследования показывают, что правильно структурированные промпты значительно улучшают способность LLM выявлять такие искажения. Эффективность метода базируется на последовательной проверке текста на наличие заранее определенных паттернов искажений, с чёткими критериями их идентификации.</p> <h2>Заключение по методам промпт-инжиниринга</h2> <p>Эти 10 методов представляют современные передовые подходы к промпт-инжинирингу, которые значительно расширяют возможности взаимодействия с языковыми моделями:</p> <ol> <li><strong>Program of Thought (PoT)</strong> - формализация рассуждений через программный код</li> <li><strong>Meta-Prompting (MP)</strong> - фокус на структуре и синтаксисе промптов</li> <li><strong>Visionary Tuning (VITO)</strong> - самотестирование и улучшение промптов через самоигру</li> <li><strong>Heuristic Prompting Strategy Search (HPSS)</strong> - комплексная интеграция ключевых факторов промптинга</li> <li><strong>Highlighted Chain of Thought (HoT)</strong> - визуальное выделение ключевых элементов рассуждения</li> <li><strong>Дивергентно-конвергентное мышление (McGyver)</strong> - структурирование творческого процесса</li> <li><strong>Персонализированные классификаторы (PC)</strong> - адаптация промптов под конкретные типы данных</li> <li><strong>Iterated Specific Prompting with Self-Prompting (ISP²)</strong> - итеративное улучшение через самопромптинг</li> <li><strong>Random Idea Injection (RII)</strong> - стимуляция творческого мышления через случайные концепции</li> <li><strong>Cognitive Bias Detection (CBD)</strong> - структурированное выявление когнитивных искажений</li> </ol> <p>Каждый из этих методов может быть адаптирован под конкретные задачи и комбинироваться с другими подходами для достижения оптимальных результатов.</p> </div></p>

    <footer class="channel-footer">
      <p>
        Материал предназначен для участников канала
        <a href="https://t.me/ainovasapiens">@ainovasapiens</a>
      </p>
    </footer>
  </article>
</div>

<div class="modal-overlay" id="lockedModalOverlay" onclick="overlayClick(event)">
  <div class="modal-box">
    <button class="close-modal" onclick="closeLockedModal()">×</button>
    <h2>Статья недоступна</h2>
    <p>
      Для получения полной версии обратитесь к боту:<br>
      <a href="https://t.me/novasapiens_bot?start=botgetreseach">
        https://t.me/novasapiens_bot?start=botgetreseach
      </a>
    </p>
  </div>
</div>

<script>
function copyCode(btn) {
  var codeBlock = btn.parentElement.querySelector("pre code");
  if (!codeBlock) return;
  var text = codeBlock.innerText;
  navigator.clipboard.writeText(text).then(function() {
      btn.innerText = "Скопировано!";
      setTimeout(function() { btn.innerText = "Копировать"; }, 2000);
  }, function(err) {
      console.error("Ошибка копирования: ", err);
  });
}

function showLockedModal() {
  document.getElementById('lockedModalOverlay').classList.add('show');
}
function closeLockedModal() {
  document.getElementById('lockedModalOverlay').classList.remove('show');
}
function overlayClick(e) {
  if (e.target.id === 'lockedModalOverlay') {
    closeLockedModal();
  }
}
</script>

</body>
</html>
